# 汇编语言 - 王爽

# 第 1 章 基础知识

CPU（Central Processing Unit，中央处理单元）

一根导线具有高低两种电平，只能传送 1 和 0 两种数据。

- 地址总线的数量影响寻址长度，一个 CPU 具有 N 根地址总线，这可以说这个 CPU 的地址总线的宽度为 N。这样的 CPU 最多可以寻找 2 的 N 次方个内存单元。
- 数据总线的数量影响一次传输的数据大小，8 根数据线，要传数字 89D8H，需要分两次，而 16 根数据线，则一次就足够了。
- 控制总线决定了 CPU 对外部器件的控制能力。



## 第 2 章 寄存器

CPU 职责：

1. 运算器进行信息处理；
2. 寄存器进行信息存储；
3. 控制器控制各种器件进行工作；
4. 内部总线连接各种器件，在他们之间进行数据的传送。



- 8086 CPU 的寄存器（14 个、均为 16 位）：

通用寄存器（用来存放一般数据）：AX BX CX DX 

为了兼容基于上代 CPU 编写的程序，1 个通用寄存器可分为 2 个 8 位寄存器使用。

AX => AH + AL
BX => BH + BL
CX => XH + CL
DX => DH + DL

SI DI SP BP IP CS SS DS ES PSW

1 个字节（byte），由 8 个 bit 组成。
1 个字（word），由 2 个 byte 组成，分别成为高、低位字节。



- 汇编指令

mov ax, 18 => 将 18 送入寄存器 AX      => AX = 18
add ax, 8  => 将寄存器 AX 中的数值加 8 => AX = AX + 8



- 16 位 CPU 的定义

1. 运算器一次最多可以处理 16 位的数据；
2. 寄存器的最大宽度为 16 位；
3. 寄存器和运算器之间的通路为 16 位。

- 物理地址 = 段地址 x 16 + 偏移地址
            （基础地址）

- 段寄存器 CS SS DS ES

CS 为代码段寄存器（Code Segment）
IP 为指令指针寄存器（Pnstruction Pointer）

CPU 将会执行 CS:IP 所指向的指令内存地址



- CPU 执行一条指令的过程

1. CPU 从 CS:IP 处读取指令；
2. CS、IP 中的内容送入地址加法器（物理地址 = 段地址 x 16 + 偏移地址）；
3. 地址加法器将物理地址送入输入输出控制电路；
4. 输入输出控制电路将物理地址送入地址总线；
5. 物理地址存放的对应指令通过数据总线传回 CPU；
6. 输入输出控制电路将指令送入指令缓冲器；
7. IP 数值将增加，偏移至下一条指令；
8. 执行控制器执行指令；
9. 执行后 AX 中的内容被改变。



- Debug 功能

```
1. Debug 的 R 命令，查看和改变 CPU 寄存器的内容；
2. Debug 的 D 命令，查看内存中的内容；
3. Debug 的 E 命令，改写内存中的内容；
4. Debug 的 U 命令，将内存中的机器指令翻译为汇编指令；
5. Debug 的 T 命令，执行一条机器语句；
6. Debug 的 A 命令，以汇编指令的格式在内存中写入一条机器指令。
```

```
r，查看所有寄存器中的数值。
r ax，改变寄存器中的数值。
d，查看内存中的内容。
d 段地址:偏移地址，查看指定地址内存内容。
d 段地址:起始偏移地址 结尾偏移地址，限定范围查看内存内容。
e 起始地址 数据 数据 数据 数据……，修改内存数据。
e 起始地址，使用询问的方式一次写入数据，空格表示确认当前数据。
u 起始地址，查看此地址中内容的机器指令。
t，执行 CS:IP 指向的机器指令。
a 起始地址，以汇编代码的形式写入指令。
q 退出 debug。
p 执行中断指令。
g 地址，直接执行到此地址所在的指令处。
p 执行完当前 loop 指令直到循环结束。
```



## 第 3 章 寄存器（内存访问）

- DS 数据段寄存器（Data Segment）

只能使用寄存器传送至 DS，不能直接数值。

使用 [x] 访问内存地址，内存基于 DS 偏移。

```assembly
mov bx, 1000H
mov ds, bx
mov al, [0]
```



- mov、add、sub 指令

```
mov 寄存器, 数据
mov 寄存器, 寄存器
mov 寄存器, 内存单元
mov 内存单元, 寄存器
mov 段寄存器, 寄存器
mov 寄存器, 段寄存器
mov 内存单元, 段寄存器
mov 段寄存器, 内存单元
add 寄存器, 数据
add 寄存器, 寄存器
add 寄存器, 内存单元
add 内存单元, 寄存器
sub 寄存器, 数据
sub 寄存器, 寄存器
sub 寄存器, 内存单元
sub 内存单元, 寄存器
```



- CPU 栈机制

任意时刻 SS:SP 指向栈顶元素

SS 栈段寄存器（Stack Segment）
SP 栈指针寄存器（Stack Pointer）



- push、pop 指令

```
push 寄存器，将一个寄存器中的数据入栈
pop 寄存器，出栈、用一个寄存器接受出栈的数据
push 段寄存器，将一个段寄存器中的数据入栈
pop 段寄存器，出栈，用一个断寄存器接受出栈的数据
push 内存单元，将一个内存单元处的字入栈
pop 内存单元，出栈，用一个内存单元接受出栈的数据
```



## 第 4 章 第一个程序

edit 编辑源代码
masm 编译器
link 链接器

- 简化编译链接步骤

```
masm 1; 需要分号。
link 1; 需要分号。
```

- 跟踪程序

```
debug 1.exe 单步跟踪 1.exe 程序。
```

cx 将显示程序的大小

整理 VirtualBox 安装 Dos 步骤。

- PSP

debug 程序时，DS 为程序所在内存段的地址，CS 为代码段地址。

CS 前面有 256 字节的程序段前缀空间，被称为“PSP”。




## 第 5 章 [BX] 和 loop 指令

- Loop 指令

cx 计数寄存器（Count ）

```
loop 标号
```


当 cx 为 0 时，执行 loop 的下一条指令，否则执行标号处指令。

- 段前缀

在汇编指令中访问内存单元，可使用段名显示指定内存地址。

```assembly
mov ax,ds:[]
mov ax,cs:[]
mov ax,ss:[]
mov ax,es:[]
```

“ds”、“cs”、“ss”、“es”，被称为“段前缀”。

- 安全空间

一般 DOS 和其他合法程序不会使用 0:200\~02ff 这段内存，所以是安全的。




## 第 6章 包含多个段的程序

- 使用 dw 定义字型数据。

```assembly
assume ds:data
data segment
    dw 0123h, 0456h, 0789h, 0, 0, 0, 0, 0
data ends
...
```



- 使用标号指定程序起始地址。

```assembly
assume cs:code
code segment
start: mov ax, 0
       mov bx, 0

       mov cx, 8
    s: add ax, 2
       loop s
       ...       
code ends
...
```

## 第 7 章 更灵活的定位内存地址的方法

- and 和 or 指令

and 指令，逻辑与指令，按位进行与运算。
or 指令，逻辑或指令，按位与或运算。



- 使用字符形式的数据

使用 db 定义字符数据，使用 '' 指明字符数据。

```assembly
assume cs:code, ds:data
data segment
    db 'unix'
    db 'forRK'
data ends

code segment
start: mov al, 'a'
       mov bl, 'b'
       mov ax, 4c00h
       int 21h
code ends
end start
```

- 用 [bx + idata] 的方式处理数组

```assembly
mov ax, [bx + 5]  ; 访问 bx + 5 位置的数据
mov ax, 5[bx]     ; 同上
```

- SI 和 DI 寄存器

[xi]

```assembly
mov ax, 0
mov ax, [bx]

mov di, 0
mov ax, [di]

mov di, 0
mov ax, [di]
```

[xi + idata]

```
mov bx, 0
mov ax, [bx + 123]

mov si, 0
mov ax, [si + 123]

mov di, 0
mov ax, [di + 123]
```

[bx + xi + idata] 

```
mov ax, [bx + si]
mov ax, [bx][si]
```

## 第 8 章 数据处理的两个基本问题

- bx、si、di、bp

只有这 4 个寄存器可被用在 [...] 中进行内存访问。

在 [...] 中使用 bp，未指定地址，则默认在 ss 中。

```assembly
mov ax, [bp]
mov ax, [bp + idata]
mov ax, [bp + si]
mov ax, [bp + si + idata]
```

- 3 种数据位置表达方式

1. idata-立即数
2. 寄存器
3. SA-段偏移地址和 EA-偏移地址

寻址方法

1. 直接寻址：[idata]
2. 寄存器间接寻址：[bx]、[si]、[di]、[bp]
3. 寄存器相对寻址：[bx + idata]、[bx].idata、idata[si]、[bx][idata]...
4. 基址变址寻址：  [bx + si]、[bx + di]、[bx][si]...
5. 相对基址变址寻址：[bx + si + idata]、[bx].idata[si]、idata[bx][si]...

- 使用 X ptr 操作符指明内存单元长度，byte 或 word

```assembly
mov word ptr ds:[0], 1   ; 指明访问 word 型数据。
inc word ptr [bx]
add word ptr [bx], 2

mov byte ptr ds:[0], 1   ; 指明访问 byte 型数据。
inc word ptr [bx]
add word ptr [bx], 2
```

- div 除法指令

除数分为 8 为和 16 位两种。
被除数默认放在 ax 或 dx 和 ax 中。

1. 如果除数为 8 位，被除数为 16 位，放在 ax 中。
2. 如果除数为 16 位，被除数为 32 位，高 16 位放在 dx 中，低 16 位放在 ax 中。

1. 除数为 8 位，则 al 中存储除法操作的商，ah 存储除法的余数。
2. 除数为 16 位，则 ax 中存储除法操作的商，dx 存储除法的余数。

```assembly
div reg
div 内存单元
```

- dd 定义双字的伪指令

```assembly
data segment
    db 1     ; 1 个字节
    dw 1     ; 1 个字
    dd 1     ; 2 个字
data ends
```

- dup 指令

定义数据时重复多次

```assembly
db 3 dup (0)       ; 等于 db 0, 0, 0
db 3 dup (0, 1, 2) ; 等于 db 0, 1, 2, 0, 1, 2, 0, 1, 2
```

## 第 9 章 转移指令的原理

- offset 操作符

offset 用来取得标号的地址。

```assembly
code segment
start: mov ax, offset start  ; 等于 mov ax, 0
    s: mov ax, offset s      ; 等于 mov ax, 3
code ends
```

- jmp 无条件跳转指令

需要提供两种信息：

1. 转移的目的地址
2. 转移的距离（段间转移、段内短转移，段内近转移）

段内短转移，修改 IP 范围为 -128\~127。

```
jmp short 标号（转到标号处执行指令）
```

```
jmp far ptr 标号  ; 段间转移
```

- 转移指令在寄存器中的 jmp 指令

```
格式：jmp 16 位 reg
功能：(IP) = (16 位 reg)
```

- 转移指令在内存中的 jmp 指令

```assembly
1. jmp word ptr 内存单元地址（段内转移）

mov ax, 0123H
mov ds:[0], ax
jmp word ptr ds:[0]   ; (IP) = 123
```

```assembly
2. jmp dword ptr 内存单元地址（段间转移）

mov ax, 0123H
mov ds:[0], ax
mov word ptr ds:[2], 0
jmp dword ptr ds:[0]    ; (CS) = 0, (IP) = 123H
```

- jcxz 有条件转移指令（短转移）

```
格式：jcxz 标号（if (cx) == 0，则转移到标号处执行）
操作：if (cx) == 0，(IP) = (IP) + 8 位位移
```

- loop 循环指令

```
格式：loop 标号（(cx) = (cx) - 1，if (cx) != 0，转移至标号处执行）
操作：if (cx) != 0，(IP) = (IP) + 8 位位移。
```

## 第 10 章 CALL 和 RET 指令

- ret 指令

ret  指令使用栈中的数据，改变 IP 的内容，实现近转移。
retf 指令使用栈中的数据，改变 CS 和 IP 的内容，实现远转移。

ret ，相当于 pop IP
retf，相当于 pop IP，pop CS

- call 指令

根据位移进行转移

```
格式：call 标号（将当前 IP 压栈，然后转到标号处执行指令）
功能：相当于 push IP，jmp near ptr 标号
```

目的地址在指令中

```
格式：call far ptr 标号 ；实现的是段间转移
功能：相当于 push CS，push IP，jmp far ptr 标号
```

转移地址在寄存器中

```
格式：call 16 位 reg
功能：相当于 push IP，jmp 16 位 reg
```

转移地址在内存中

```
1. 格式：call word ptr 内存单元地址
   功能：相当于 push IP，jmp word ptr

2. 格式：call dword ptr 内存单元地址
   功能：相当于 push CS，push IP，jmp dword ptr 内存单元地址
```


## 第 11 章 内中断

## 第 13 章 int 指令

## 第 14 章 端口

## 第 15 章 外中断

## 第 16 章 直接定址表

## 第 17 章 使用 BIOS 进行键盘输入和磁盘读写

