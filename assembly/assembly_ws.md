























# 汇编语言 - 王爽

- [第 1 章 基础知识](#第-1-章-基础知识)
- [第 2 章 寄存器](#第-2-章-寄存器)
- [第 3 章 寄存器（内存访问）](#第-3-章-寄存器（内存访问）)
- [第 4 章 第一个程序](#第-4-章-第一个程序)
- [第 5 章 [BX] 和 loop 指令](#第-5-章-[bx]-和-loop-指令)
- [第 6章 包含多个段的程序](#第-6章-包含多个段的程序)
- [第 7 章 更灵活的定位内存地址的方法](#第-7-章-更灵活的定位内存地址的方法)
- [第 8 章 数据处理的两个基本问题](#第-8-章-数据处理的两个基本问题)
- [第 9 章 转移指令的原理](#第-9-章-转移指令的原理)
- [第 10 章 CALL 和 RET 指令](#第-10-章-call-和-ret-指令)
- [第 11 章 标志寄存器](#第-11-章-标志寄存器)
- [第 12 章 内中断](#第-12-章-内中断)
- [第 13 章 int 指令](#第-13-章-int-指令)
- [第 14 章 端口](#第-14-章-端口)
- [第 15 章 外中断](#第-15-章-外中断)
- [第 16 章 直接定址表](#第-16-章-直接定址表)
- [第 17 章 使用 BIOS 进行键盘输入和磁盘读写](#第-17-章-使用-bios-进行键盘输入和磁盘读写)

# 第 1 章 基础知识

CPU（Central Processing Unit，中央处理单元）

一根导线具有高低两种电平，只能传送 1 和 0 两种数据。



- 汇编语言构成

1. 汇编指令：机器码的助记符，存在对应的机器码；
2. 伪指令：没有对应的机器码，由编译器执行，计算机并不执行；
3. 其他符号：如+、-、\*、/、等，由编译器识别，没有对应机器码。



- CPU 与芯片沟通的 3 类交互

1. 存储单元的地址（地址信息）；
2. 器件的选择，读或写的命令（控制信息）；
3. 读或写的数据（数据信息）。



- 地址总线

一个 CPU 有 N 根地总线，可以说这个 CPU 的地址总线的宽度为 N。这样的 CPU 最多
可以寻找 2 的 N 次方个内存单元。



- 数据总线

一个 CPU 有 8 根数据总线，那么一次可以传送一个 8 位的二进制数据（byte），16 根
数据总线可以一次传送两个 byte。



- 控制总线

控制总线的数量，决定了 CPU 对外部器件的控制能力。



# 第 2 章 寄存器

- CPU 职责

1. 运算器进行信息处理；
2. 寄存器进行信息存储；
3. 控制器控制各种器件进行工作；
4. 内部总线连接各种器件，在他们之间进行数据的传送。

8086 CPU 的寄存器共有 14 个寄存器，均为 16 位。



- 通用寄存器（用来存放一般数据）

1. AX Accumlator，累加器；
2. BX Base X，基址寄存器；
3. CX Counter X，计数寄存器；
4. DX Data X，数据寄存器。



- 为了兼容基于上代 CPU 编写的程序，1 个通用寄存器可分为 2 个 8 位寄存器使用。

1. AX >> AH + AL；
2. BX >> BH + BL；
3. CX >> XH + CL；
4. DX >> DH + DL。



- 8086 CPU 可处理两种尺寸的数据

1. 1 个字节（byte），由 8 个 bit 组成；
2. 1 个字（word），由 2 个 byte 组成，分别成为高、低位字节。



- 汇编指令

mov ax, 18 => 将 18 送入寄存器 AX      => AX = 18
add ax, 8  => 将寄存器 AX 中的数值加 8 => AX = AX + 8



- 16 位 CPU 的定义

1. 运算器一次最多可以处理 16 位的数据；
2. 寄存器的最大宽度为 16 位；
3. 寄存器和运算器之间的通路为 16 位。

8086 CPU 有 20 位地址总线，可以传送 20 位地址，达到 1 MB 寻址能力。
8086 CPU 本身是 16 位结构，内部一次性处理、传输、暂存的地址为 16 位。
如果直接发出地址，那么只能送出 16 位的地址，表现出的寻址能力只有 64KB。

所以采用地址加法器地址加法器将两个 16 位地址合成物理地址

```
物理地址 = 段地址 x 16 + 偏移地址
         = 基础地址 + 偏移地址
```



- 段

编程时，用段地址 x 16 定位段的起始地址（基础地址）

16 位地址的寻址能力为 64KB，一个段的长度最大位 64KB。



- 段寄存器

1. CS 代码段寄存器（Code Segment）；
2. IP 指令指针寄存器（Pnstruction Pointer）。

CPU 将会执行 CS:IP 所指向的指令内存地址



- CPU 执行一条指令的过程

1. CPU 从 CS:IP 处读取指令；
2. CS、IP 中的内容送入地址加法器（物理地址 = 段地址 x 16 + 偏移地址）；
3. 地址加法器将物理地址送入输入输出控制电路；
4. 输入输出控制电路将物理地址送入地址总线；
5. 物理地址存放的对应指令通过数据总线传回 CPU；
6. 输入输出控制电路将指令送入指令缓冲器；
7. IP 数值将增加，偏移至下一条指令；
8. 执行控制器执行指令；
9. 执行后 AX 中的内容被改变。



- Debug

Debug 是 DOS、WIndows 都提供的实模式（8086 方式）程序的调试工具。

```
r，查看所有寄存器中的数值。
r ax，改变寄存器 ax 中的数值。
d，查看内存中的内容。
d 段地址:偏移地址，查看指定地址内存内容。
d 段地址:起始偏移地址 结尾偏移地址，限定范围查看内存内容。
e 起始地址 数据 数据 数据 数据……，修改内存数据。
e 起始地址，使用询问的方式一次写入数据，空格表示确认当前数据。
u 起始地址，查看此地址中内容的机器指令。
t，执行 CS:IP 指向的机器指令。
a 起始地址，以汇编代码的形式写入指令。
q 退出 debug。
p 执行中断指令。
g 地址，直接执行到此地址所在的指令处。
p 执行完当前 loop 指令直到循环结束。
```



# 第 3 章 寄存器（内存访问）

- DS 数据段寄存器（Data Segment）

只能使用寄存器传送至 DS，不能使用立即数。

```assembly
mov ax, 1000H
mov ds, ax
```

使用 [x] 访问内存地址，内存基于 DS 偏移。

```assembly
mov bx, 1000H
mov ds, bx
mov al, [0]
```



- mov、add、sub 指令

```
mov 寄存器, 数据
mov 寄存器, 寄存器
mov 寄存器, 内存单元
mov 内存单元, 寄存器
mov 段寄存器, 寄存器
mov 寄存器, 段寄存器
mov 内存单元, 段寄存器
mov 段寄存器, 内存单元
add 寄存器, 数据
add 寄存器, 寄存器
add 寄存器, 内存单元
add 内存单元, 寄存器
sub 寄存器, 数据
sub 寄存器, 寄存器
sub 寄存器, 内存单元
sub 内存单元, 寄存器
```



- CPU 栈机制

任意时刻 SS:SP 指向栈顶元素

1. SS 栈段寄存器（Stack Segment）；
2. SP 栈指针寄存器（Stack Pointer）。



- push、pop 指令

```
push 寄存器，将一个寄存器中的数据入栈
pop 寄存器，出栈、用一个寄存器接受出栈的数据
push 段寄存器，将一个段寄存器中的数据入栈
pop 段寄存器，出栈，用一个断寄存器接受出栈的数据
push 内存单元，将一个内存单元处的字入栈
pop 内存单元，出栈，用一个内存单元接受出栈的数据
```



# 第 4 章 第一个程序

edit 编辑源代码
masm 编译器
link 链接器



- 简化编译链接步骤

```
masm 1; 需要分号。
link 1; 需要分号。
```



- 跟踪程序

```
debug 1.exe 单步跟踪 1.exe 程序。
```

cx 将显示程序的大小

整理 VirtualBox 安装 Dos 步骤。



- PSP

debug 程序时，DS 为程序所在内存段的地址，CS 为代码段地址。

CS 前面有 256 字节的程序段前缀空间，被称为“PSP”。



# 第 5 章 [BX] 和 loop 指令

- Loop 指令

cx 计数寄存器（Counter,）

当 cx 为 0 时，执行 loop 的下一条指令，否则执行标号处指令。

```
loop 标号
```



- 段前缀

在汇编指令中访问内存单元，可使用段名显示指定内存地址。

```assembly
mov ax,ds:[]
mov ax,cs:[]
mov ax,ss:[]
mov ax,es:[]
```

“ds”、“cs”、“ss”、“es”，被称为“段前缀”。



- 安全空间

一般 DOS 和其他合法程序不会使用 0:200\~02ff 这段内存，所以是安全的。



# 第 6章 包含多个段的程序

- 使用 dw 定义字型数据

```assembly
assume ds:data
data segment
  dw 0123h, 0456h, 0789h, 0, 0, 0, 0, 0
data ends
...
```



- 使用标号指定程序起始地址

```assembly
assume cs:code
code segment
start:
  mov ax, 0
  mov bx, 0

  mov cx, 8
s:
  add ax, 2
  loop s
  ...       
code ends
...
```



# 第 7 章 更灵活的定位内存地址的方法

- and 和 or 指令

1. and 指令，逻辑与指令，按位进行与运算；
2. or 指令，逻辑或指令，按位与或运算。



- 使用字符形式的数据

使用 db 定义字符数据，使用 '' 指明字符数据。

```assembly
assume cs:code, ds:data
data segment
  db 'unix'
  db 'forRK'
data ends

code segment
start: 
  mov al, 'a'
  mov bl, 'b'
  mov ax, 4c00h
  int 21h
code ends
end start
```



- 用 [bx + idata] 的方式处理数组

```assembly
mov ax, [bx + 5]  ; 访问 bx + 5 位置的数据
mov ax, 5[bx]     ; 同上
```



- SI 和 DI 寄存器

1. SI Source Index，源变址寄存器；
2. DI Destination Index，目的变址寄存器。

[xi]

```assembly
mov ax, 0
mov ax, [bx]

mov di, 0
mov ax, [di]

mov di, 0
mov ax, [di]
```

[xi + idata]

```
mov bx, 0
mov ax, [bx + 123]

mov si, 0
mov ax, [si + 123]

mov di, 0
mov ax, [di + 123]
```

[bx + xi + idata] 

```
mov ax, [bx + si]
mov ax, [bx][si]
```



# 第 8 章 数据处理的两个基本问题

- bx、si、di、bp

只有这 4 个寄存器可被用在 [...] 中进行内存访问。

在 [...] 中使用 bp，未指定地址，则默认在 ss 中。

```assembly
mov ax, [bp]
mov ax, [bp + idata]
mov ax, [bp + si]
mov ax, [bp + si + idata]
```



- 3 种数据位置表达方式

1. idata，立即数；
2. 寄存器；
3. SA（段偏移地址）和 EA（偏移地址）。



- 寻址方法

1. 直接寻址：[idata]
2. 寄存器间接寻址：[bx]、[si]、[di]、[bp]
3. 寄存器相对寻址：[bx + idata]、[bx].idata、idata[si]、[bx][idata]...
4. 基址变址寻址：  [bx + si]、[bx + di]、[bx][si]...
5. 相对基址变址寻址：[bx + si + idata]、[bx].idata[si]、idata[bx][si]...



- 使用 X ptr 操作符指明内存单元长度，byte 或 word

```assembly
mov word ptr ds:[0], 1   ; 指明访问 word 型数据。
inc word ptr [bx]
add word ptr [bx], 2

mov byte ptr ds:[0], 1   ; 指明访问 byte 型数据。
inc word ptr [bx]
add word ptr [bx], 2
```



- div 除法指令

除数分为 8 为和 16 位两种。
被除数默认放在 ax 或 dx 和 ax 中。

1. 如果除数为 8 位，被除数为 16 位，放在 ax 中；
2. 如果除数为 16 位，被除数为 32 位，高 16 位放在 dx 中，低 16 位放在 ax 中。

1. 除数为 8 位，则 al 中存储除法操作的商，ah 存储除法的余数；
2. 除数为 16 位，则 ax 中存储除法操作的商，dx 存储除法的余数。

```assembly
div reg
div 内存单元
```



- dd 定义双字的伪指令

```assembly
data segment
  db 1     ; 1 个字节
  dw 1     ; 1 个字
  dd 1     ; 2 个字
data ends
```



- dup 指令

定义数据时重复多次

```
db 重复的次数 dup（重复的字节型数据）
dw 重复的次数 dup（重复的字型数据）
dd 重复的次数 dup（重复的双字型数据）
```



# 第 9 章 转移指令的原理

- offset 操作符

offset 用来取得标号的地址。

```assembly
code segment
start: 
  mov ax, offset start  ; 等于 mov ax, 0
  s: mov ax, offset s   ; 等于 mov ax, 3
code ends
```



- jmp 无条件跳转指令

需要提供两种信息：

1. 转移的目的地址
2. 转移的距离（段间转移、段内短转移，段内近转移）

段内短转移，修改 IP 范围为 -128\~127。

```
jmp short 标号（转到标号处执行指令）
```

```
jmp far ptr 标号  ; 段间转移
```



- 转移指令在寄存器中的 jmp 指令

```
格式：jmp 16 位 reg
功能：(IP) = (16 位 reg)
```



- 转移指令在内存中的 jmp 指令

```assembly
1. jmp word ptr 内存单元地址（段内转移）

mov ax, 0123H
mov ds:[0], ax
jmp word ptr ds:[0]   ; (IP) = 123
```

```assembly
2. jmp dword ptr 内存单元地址（段间转移）

mov ax, 0123H
mov ds:[0], ax
mov word ptr ds:[2], 0
jmp dword ptr ds:[0]    ; (CS) = 0, (IP) = 123H
```



- jcxz 有条件转移指令（短转移）

```
格式：jcxz 标号（if (cx) == 0，则转移到标号处执行）
操作：if (cx) == 0，(IP) = (IP) + 8 位位移
```



- loop 循环指令

```
格式：loop 标号（(cx) = (cx) - 1，if (cx) != 0，转移至标号处执行）
操作：if (cx) != 0，(IP) = (IP) + 8 位位移。
```



# 第 10 章 CALL 和 RET 指令

- ret 指令

ret  指令使用栈中的数据，改变 IP 的内容，实现近转移。
retf 指令使用栈中的数据，改变 CS 和 IP 的内容，实现远转移。

ret ，相当于 pop IP
retf，相当于 pop IP，pop CS



- call 指令

根据位移进行转移

```
格式：call 标号（将当前 IP 压栈，然后转到标号处执行指令）
功能：相当于 push IP，jmp near ptr 标号
```

目的地址在指令中

```
格式：call far ptr 标号 ；实现的是段间转移
功能：相当于 push CS，push IP，jmp far ptr 标号
```

转移地址在寄存器中

```
格式：call 16 位 reg
功能：相当于 push IP，jmp 16 位 reg
```

转移地址在内存中

```
1. 格式：call word ptr 内存单元地址
   功能：相当于 push IP，jmp word ptr

2. 格式：call dword ptr 内存单元地址
   功能：相当于 push CS，push IP，jmp dword ptr 内存单元地址
```



- call 和 ret 配合使用，形成子程序

```
标号：指令
      ret
```

```assembly
assume cs:code
code segment
main: 
  ...
  call sub1
  ...
  mov ax, 4c00h
  int 21h
sub1:
  ...
  call sub2   
  ...
  ret
sub2:
  ...
  ret
code ends
end main
```



- mul 指令

乘法指令

两个相乘的数，都是 8 位或者都是 16 位。

如果是 8 位，一个默认放在 AL 中，另一个放在 8 位 reg 或内存字节单元中。
如果是 16 位，一个默认放在 AX 中，另一个放在 16 位 reg 或内存字单元中。

如果是 8 位相乘，结果放在 AX 中，如果是 16 位相乘，结果高位默认在 DX 中存方，低位在 AX 中存放。

```
mul reg
mul 内存单元 
```

# 第 11 章 标志寄存器

标志寄存器作用：

1. 用来存储相关最指令的某些执行结果；
2. 用来为 CPU 执行相关指令提供行为依据；
2. 用来控制 CPU 的相关工作方式。

flag 寄存器按位起作用：

```
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
|  |  |  |  |OF|DF|IF|TF|SF|ZF|  |AF|  |PF|  |CF|
```

- AF 寄存器

Auxiliary Carry FLag，辅助进位标志位，字节操作中发生低半个字节向高半个字节借位
或者进位或字操作中发生低字节向高字节借位或者进位。



- ZF 寄存器

Zero Flag，零标志位，它记录相关指令执行后，其结果是否为 0。
如果结果为 0，则 zf=1，如果结果不为 0，则 zf = 0。



- PF 标志

Parity Flag，奇偶标志位，它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是
否为偶数。如果 1 的个数为偶像，pf = 1，如果为奇数，那么 pf = 0。



- SF 标志

Sign Flag，符号标志位，它记录相关指令执行后，其结果为负。
如果结果为负，sf = 1，如果非负，sf = 0。



- CF 标志

Carry Flag，进位标志位，一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位
向更高位的进位制，或从更高位的错位值。



- OF 标志

Overflow Flaga，溢出标志位，一般情况下，OF 记录了有符号数运算的结果是否发生了移除。
如果发生溢出，OF = 1；如果没有 OF = 0

CF 是对无符号数运行有意义的标志位，OF 是对有符号数有意义的标志位。



- TF 寄存器

Trap Flag，追踪标志位，用于调式时单步中断。



- IF 寄存器

Interrupt-Enable Flag，中断允许标志位，决定 CPU 是否可响应外部可屏蔽中断。



- DF 寄存器

Direction Flag，方向标志位，用于在串处理指令中，控制每次操作后 SI 和 DI 是自增
还是自减的方向。



- abc 指令

带进位加法指令，它利用了 CF 上记录的进位值。

```
格式：abc 操作对象 1，操作对象 2
功能：操作对象 1 = 操作对象 1 + 操作对象 2 + CF
```



- sbb 指令

带借位减法指令，它利用了 CF 位上记录的借位值。

```
格式：sbb 操作对象 1，操作对象 2
功能：操作对象 1 = 操作对象 1 - 操作对象 2 - CF
```



- cmp 比较指令

cmp 相当于减法指，只是不保存结果。

```
格式：cmp 操作对象 1，操作对象 2
功能：计算操作对象 1 - 操作对象 2，根据结果设置标志寄存器
```

cmp ax, bx

```
zf = 1，表示 ax == bx
zf = 0，表示 ax != bx
cf = 1，表示 ax < bx
cf = 0，表示 ax >= bx
cf = 0 且 zf = 0，表示 ax > bx
cf = 1 或 zf = 1，表示 ax <= bx
```



- 检测比较结果的条件转移指令

转移表示能够修改 IP，根据某种条件改变 IP。

jcxz 就是一个条件转移指令。

| 指令 | 含义         | 相关检测标志位   |
| ---- | ------------ | ---------------- |
| je   | 等于则转移   | zf = 1           |
| jne  | 不等于则转移 | zf = 0           |
| jb   | 低于则转移   | cf = 1           |
| jnb  | 不低于则转移 | cf = 0           |
| ja   | 高于则转移   | cf = 0 且 zf = 0 |
| jna  | 不高于则转移 | cf = 1 或 zf = 1 |



- DF 标志和串传送指令

DF 方向标志位。在串处理指令中，控制每次操作后 si、di 的递减。

df = 0 每次操作后 si、di 递增
df = 1 每次操作后 si、di 递减

1. 传送 byte

```
格式：movsb
功能：执行 movsb 指令相当于如下伪代码
mov es:[di], byte ptr ds:[si]

if df == 0:
inc si, inc di

if if == 1:
dec si, dec di
```

2. 传送 word

```
格式：movsw
功能：每次将 si 和 di 递增或递减 2
```

rep 指令，循环传送串。

```assembly
rep movsb
rep movsw

相当于
s: mobsb
   loop s
```

cld 指令：将标志寄存器的 df 位置 0
std 指令：将标志寄存器的 df 位置 1



- pushf 和 popf

pushf 的功能是将标志寄存器的值压栈，popf 是出栈数据后标志送入寄存器。

它们位访问标志寄存器提供了方法。



- 标志寄存器在 debug 中的表示

| 标志 | 值为 1 的标记 | 值为 0 的标记 |
| ---- | ------------- | ------------- |
| of   | OV            | NV            |
| sf   | NG            | PL            |
| zf   | ZR            | NZ            |
| pf   | PE            | PO            |
| cf   | CY            | NC            |
| df   | DN            | IP            |

# 第 12 章 内中断

- 内中断的产生时机

1. 除法错误，比如执行 div 指令时产生的除法溢出；
2. 单步执行；
3. 执行 into 指令；
4. 执行 int 指令。



- 中断向量表

1. 中断向量表在内存中保存，存放着 256 个中断源对应的中断处理程序的入口；
2. 对于 8086 PC 机，中断向量表指定放在内存地址 0 处。从内存 0000:0000 到 0000:03FF
的 1024 个单元中存放着中断向量表；
3. 一个表项存放一个中断向量，包括中断处理程序的段地址和入口地址，占 2 个字。



- CPU 收到中断信息后的中断过程

1. （从中断信息中）取得中断类型码；
2. 标志寄存器的值入栈（因为在中断过程中要改变标志寄存器的值，所以先保存至栈中）；
3. 设置标志寄存器的第 8 位 TF 和第 9 位 IF 的值为 0；
4. CS 的内容入栈；
5. IP 的内容入栈；
6. 从内存地址为中断类型码 x 4 和中断类型码 x 4 + 2 的两个字单元中读取中断处理
程序的入口地址设置 IP 和 CS。



- 中断处理程序编写步骤

1. 保存用到的寄存器；
2. 处理中断；
3. 恢复用到的寄存器；
4. 用 iret 指令返回。



- iret 指令

伪代码描述:

```assembly
pop IP
pop CS
popf
```



- 单步中断

1. 取得中断类型码 N；
2. 标志寄存器入栈，TF = 0，IF = 0；
3. CS、IP 入栈；
4. (IP) = (N \* 4)，(CS) = (N \* 4 + 2)



# 第 13 章 int 指令

CPU 执行 int n 指令，相当于引发一个 n 号中断过程。

- BIOS 主要包含以下内容

1. 硬件系统的检测和初始化程序；
2. 外部中断和内部中断的中断例程；
3. 用于对硬件设备进行 I/O 操作的中断例程；
4. 其他和硬件系统相关的中断例程。



# 第 14 章 端口

- 除了和 CPU 通过总线连接的存储器外，还有如下相关芯片

1. 各种接口卡（例如：网卡、显卡）上的接口芯片，它们控制接口卡进行工作；
2. 主板上的接口芯片，CPU 通过它们对部分外设进行访问；
3. 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。



- 这些芯片都具有一组可以由 CPU 读写的寄存器，它们

1. 都和 CPU 的总线相连，当然这种连接是通过它们所在的芯片进行的；
2. CPU 对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。



- CPU 可读写以下 3 个地方的数据

1. CPU 内部的寄存器；
2. 内存单元；
3. 端口。

端口读写只能通过 in 和 out 指令读取和写入数据。

```assembly
in al, 60h   ; 从 60h 端口读入一个字节 
out 20h, al  ; 向 20h 端口写入一个字节 
```

在 in 和 out 指令中，只能使用 ax 或 al 来存放从端口要读入或读出的数据。



- CMOS RAM 芯片特征

1. 包含一个时钟和一个有 128 个存储单元的 RAM 存储器（早期的计算机为 64 字节）；
2. 该芯片靠电池供电。所以，关机后内部的实时钟仍可正常工作，RAM 中的信息不丢失；
3. 128 字节的 RAM 种，内部实时种占用 0-0dh 单元来保存时间信息，其余大部分单元
用于保存系统配置信息，供系统启动时 BIOS 程序读取。BISO 提供了相关程序，使我们
在开机的时候配置 CMOS RAM 种的系统信息；
4. 该芯片内部有两个端口，端口地址为 70h 和 71h，CPU 通过这两个端口来读写 CMOS；
5. 70h 为地址端口，存放要访问的 CMOS RAM 单元的地址；71h 为数据端口，存放从指
定的 CMOS RAM 单元中读取的数据，或要写入到其中的数据。

```
; 读取 2 号单元
1. 将 2 送入端口 70h；
2. 从端口 71h 读出 2 号单元的内容。
```



- shl 和 shr 逻辑位移指令

shl 逻辑左移指令：

```
1. 将一个寄存器或内存单元中的数据向左移位；
2. 将最后移出的一位写入 CF 中；
3. 最低位用 0 补充。
```

shr 逻辑右移指令

```
1. 将一个寄存器或内存单元中的数据向右移位；
2. 将最后移出的一位写入 CF 中；
3. 最高位用 0 补充。
```



# 第 15 章 外中断

- 外中断源

1. 可屏蔽中断，它是 CPU 可以不响应的外中断。CPU 是否响应可屏蔽中断，要看标志寄
存器的 IF 位的设置；
2. 不可屏蔽中断，它是 CPU 必须响应的外中断。当 CPU 检测到不可屏蔽的中断信息时，
则在执行完当前指令后，立即响应，引发中断过程。



# 第 16 章 直接定址表

- 使用标号表代表内存地址

```assembly
assume cs:code
code segment
  a db 1, 2, 3, 4, 5, 6, 7, 8
  b dw 0
start:
  mov si, 0
  mov cx, 8
s:
  mov al, a[si]
  mov ah, 0
  add b, 0
  inc si
  loop s
  mov ax, 4c00h
  int 21h
code ends
end start
```



# 第 17 章 使用 BIOS 进行键盘输入和磁盘读写

键盘输入将引发 9 号中断，BIOS 提供了 int 9 中断例程。CPU 执行 9 号例程，从 60h
端口读出扫描码，并转化位响应 ASCII 码或状态信息，存储在指定空间中。

- 使用 int 16h 中断读取键盘输入

```assembly
mov ah, 0
int 26h
```

结果：(ah) = 扫描码，(al) = ASCII 码。



- int 16h 中断例程的 0 号功能，进行如下的工作

1. 检测键盘缓冲区是否有数据；
2. 没有则继续做第 1 步；
3. 读取缓冲区第一个字单元中的键盘输入；
4. 将读取的扫描码送入 ah，ASCII 码送入 al；
5. 将一度去的键盘输入从缓冲区中删除。



- 程序：根据用户输入，设置屏幕字符颜色，'r'，'g'，'b' 分别对应红、蓝、绿。

```assembly
assume cs:code
code segment
start:
  mov ah, 0
  int 16h      ; 键盘中断例程

  mov ah, 1    ; 默认为蓝色属性
  cmp al, 'r'  ; 判断键盘字符
  je red
  cmp al, 'g'
  je green
  cmp al, 'b'
  je blue
  jmp short sret
red:
  shl ah, 1    ; 设置红色属性
green:
  shl ah, 1
blue:
  mov bx, 0b800h
  mov es, bx
  mov bx, 1
  mov cx, 2000
s:
  and byte ptr es:[bx],1111100b
  or es:[bx], ah
  add bx, 2
  loop s       ; 改变显示缓冲区所有字符颜色。
code ends
end start
```