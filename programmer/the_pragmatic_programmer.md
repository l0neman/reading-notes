# 程序员修炼之道

- [程序员修炼之道](#程序员修炼之道)
- [序](#序)
- [第 1 章 注重实效的哲学 A Pragmatic Philosophy](#第-1-章-注重实效的哲学-a-pragmatic-philosophy)
  - [ 1 我的源码让猫吃了](#-1-我的源码让猫吃了)
  - [2 软件的熵](#2-软件的熵)
  - [3 石头汤与煮青蛙](#3-石头汤与煮青蛙)
  - [4 足够好的软件](#4-足够好的软件)
  - [5 你的知识资产](#5-你的知识资产)
  - [6 交流](#6-交流)
- [第 2 章 注重实效的途径 A Pragmatic Approach](#第-2-章-注重实效的途径-a-pragmatic-approach)
  - [7 重复的危害](#7-重复的危害)
  - [8 正交性](#8-正交性)
- [可撤销性](#可撤销性)
  - [10 曳光弹](#10-曳光弹)
  - [11 原型与便笺](#11-原型与便笺)
  - [12 领域语言](#12-领域语言)
  - [13 估算](#13-估算)
- [第 3 章 基本工具 The Basic Tools](#第-3-章-基本工具-the-basic-tools)
  - [14 纯文本的威力](#14-纯文本的威力)
  - [15 shell 游戏](#15-shell-游戏)
  - [16 强力编辑](#16-强力编辑)
  - [17 源码控制](#17-源码控制)
- [18 调试](#18-调试)
  - [19 文本操纵](#19-文本操纵)
  - [20 代码生成器](#20-代码生成器)
- [第 4 章 注重实效的偏执 Pragmatic Paranoia](#第-4-章-注重实效的偏执-pragmatic-paranoia)
  - [21 按合约设计](#21-按合约设计)
  - [21 死程序不说谎](#21-死程序不说谎)
  - [23 断言式编程](#23-断言式编程)
  - [24 何时使用异常](#24-何时使用异常)
- [25 怎样配平资源](#25-怎样配平资源)
- [第 5 章 弯曲、或折断 Bend, or Break](#第-5-章-弯曲或折断-bend-or-break)
  - [26 解耦与得墨忒耳法则](#26-解耦与得墨忒耳法则)
  - [27 元程序设计](#27-元程序设计)
  - [28 时间耦合](#28-时间耦合)
  - [29 它只是视图](#29-它只是视图)
  - [30 黑板](#30-黑板)
- [第 6 章 当你编码时 While You Are Coding](#第-6-章-当你编码时-while-you-are-coding)
  - [31 靠巧合编程](#31-靠巧合编程)
  - [32 算法速率](#32-算法速率)
  - [33 重构](#33-重构)
  - [34 易于测试的代码](#34-易于测试的代码)
  - [35 邪恶的向导](#35-邪恶的向导)
- [第 7 章 在项目开始之前 Before The Project](#第-7-章-在项目开始之前-before-the-project)
  - [36 需求之坑](#36-需求之坑)
  - [37 解开不可能的谜题](#37-解开不可能的谜题)
  - [38 等你准备好](#38-等你准备好)
  - [39 规范陷阱](#39-规范陷阱)
  - [40 圆圈与箭头](#40-圆圈与箭头)
- [注重实效的项目 Pragmatic Projects](#注重实效的项目-pragmatic-projects)
  - [41 注重实效的团队](#41-注重实效的团队)
  - [42 无处不在的自动化](#42-无处不在的自动化)
  - [43 无情的测试](#43-无情的测试)
  - [44 全都是写](#44-全都是写)
  - [45 极大的期望](#45-极大的期望)
  - [46 傲慢与偏见](#46-傲慢与偏见)



# 序

提示 1：

```
Care About Your Craft
关心你的技艺
```

如果你不在乎能否漂亮地开发出软件，你又为何要耗费生命去开发软件呢？



提示 2：

```
Think! About your Work
思考！你的工作
```

关掉自动驾驶仪，接管操作。不断地批评和评估你的工作。



# 第 1 章 注重实效的哲学 A Pragmatic Philosophy

##  1 我的源码让猫吃了

> 在所有的弱点中，最大的弱点就是害怕暴露弱点。

负责，责任是主动担负的东西，如果同意要为某个结果负责，就应该切实负起责任。犯错误或者判断失误时，诚实的承认它，并设法给出各种选择。



提示 3：

```
Provide Optins，Don't Make Lame Excuses
提供各种选择，不要找蹩脚的借口
```

要提供各种选择，而不是找借口。不要说事情做不到；说明能够做什么。



## 2 软件的熵

当软件中的无序增长时，称为“软件腐烂”。

- 破窗户

破窗户理论，一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑的居民带来一种废弃感，于是又一扇窗户破了，出现了乱涂乱画，开始了严重的结构损坏。在较短的时间里，建筑被损毁的超过了业主愿意修理的程度，废弃感变为了现实。



提示 4：

```
Don't Live with Broken Windows
不要容忍破窗户
```

当你看到糟糕的设计、错误的决策和糟糕的代码时，修正它们。



- 灭火

如果发现所在团队和项目的代码十分漂亮，编写整洁、设计良好、并且很优雅，你就很可能会格外注意不去把它弄脏，即使有火在咆哮（最后期限、发布日期、会展演示等），你也不会想成为第一个弄脏东西的人。



## 3 石头汤与煮青蛙

启动杂役（start-up fatigue）

设计出你可以合理要求的东西，好好开发它。一旦完成，就拿给大家看，让他们大吃一惊。然后说：“要是我们增加……可能就会更好。”假装那不重要。等着他们开始要你增加你本来就想要的功能。人们发现，参与正在发生的成功要更容易。让他们瞥见未来，你就能让他们聚集在你周围



提示 5：

```
Be a Catalyst for Change
做变化的催化剂
```

你不能强迫人们改变。相反，要向他们展示未来可能会怎样，并帮助他们参与对未来的创造。



提示 6：

```
Remember the Big Picture
记住大图景
```

不要太过专注于细节，以致忘了查看你周围正在发生什么。



## 4 足够好的软件

> 欲求更好，常把好事变糟。

- 让你的用户参与权衡



提示 7：

```
Make Quality a Requirements Issue
使质量成为需求问题
```

让你的用户参与确定项目真正的质量需求。

今天的了不起的软件常常比明天的完美软件更可取。如果你给用户某样东西，让他们及早使用，他们的反馈常常会把你引向更好的最终解决方案



- 知道何时止步

不要因为过度修饰和过于求精而毁损完好的程序。继续前进，让你的代码凭着自己的质量站立一会儿。它也许不完美，但不用担心：它不可能完美。



## 5 你的知识资产

> 知识上的投资总能得到最好的回报。

- 经营你的资产

定期投资。必须定期为你的知识资产投资。即使投资量很小，习惯自身也和总量一样重要。

多元化。你知道的不同的事情越多，你就越有价值。作为底线，你需要知道你目前所用的特定技术的各种特性。

管理风险。不要把你所有的技术鸡蛋放在一个篮子里。

低买高卖。在新兴的技术流行之前学习它可能就和找到被低估的股票一样困难，但所得到的就和那样的股票带来的收益一样。

重新评估和平衡。这是一个非常动荡的行业。你上个月开始研究的热门技术现在也许已像石头一样冰冷。



提示 8：

```
Invest Regularly in Your Knowledge Portfolio
定期为你的知识资产投资
```

- 目标

每年至少学习一种新语言。不同语言以不同方式解决相同的问题。通过学习若干不同的方法，可以帮助你拓宽你的思维，并避免墨守成规。

每季度阅读一本技术书籍。一旦你养成习惯，就一个月读一本书。在你掌握了你正在使用的技术之后，扩宽范围，阅读一些与你的项目无关的书籍。

也要阅读非技书籍。记住计算机是由人——你在设法满足其需要的人——使用的，这十分重要。

上课。在本地的学院或大学、或是将要来临的下一次会展上寻找有趣的课程。

参加本地用户组织。不要只是去听讲，而要主动参与。与世隔绝对你的职业生涯来说可能是致命的；打听一下你们公司以外的人都在做什么。

实验不同的环境。如果你只在Windows上工作，就在家玩一玩Unix（可自由获取的Linux就正好）。如果你只用过makefile和编辑器，就试一试IDE，反之亦然。

跟上潮流。订阅商务杂志和其他期刊。选择所涵盖的技术与你当前的项目不同的刊物。

上网。上网冲浪，查找论文、商业站点，以及其他任何你可以找到的信息来源。



- 学习的机会

如果你自己找不到答案，就去找出能找到答案的人。不要把问题搁在那里。与他人交谈可以帮助你建立人际网络，而因为在这个过程中找到了其他不相关问题的解决方案。

所有阅读和研究都需要时间，而时间已经很短缺。所以你需要预先规划。让自己在空闲的片刻时间里总有东西可读。



- 批判的思考

批判的思考你读到的和听到的。你需要确保你的资产中的知识是准确的，并且没有受到供应商或媒体炒作的影响。Web搜索引擎把某个页面列在最前面，并不意味着那就是最佳选择；内容供应商可以付钱让自己排在前面。



提示 9：

```
Criticlly Analyze What You Read and Hear
批判地分析你读到的和听到的
```

不要被供应商、媒体炒作、或教条左右。要依照你自己的看法和你的项目的情况去对信息进行分析。



## 6 交流

> 我相信，被打量比被忽略要好。

- 知道你想要说什么

在工作中使用的更为正式的交流方式中，最困难的部分也许是确切地弄清楚你想要说什么。

规划你想要说的东西。写出大纲。然后问你自己：“这是否讲清了我要说的所有内容？”提炼它，直到确实如此为止。



- 了解你的听众

只有当你是在传达信息时，你才是在交流。

WISDOM 离合诗

```
                  What do you want them to learn?   你想让他们学到什么？
What is their interest in what you've got to say?   他们对你讲的什么感兴趣？
                      How sophisticated are they?   他们有多富有经验？
                    How much detail do they want?   他们想要多少细节？
         Whom do you want to own the information?   你想要让谁拥有这些信息？
        How can you motive them to listen to you?   你如何促使他们听你说话？
```



- 选择时机

为了了解你的听众需要听到什么，你需要弄清楚他们的“轻重缓急”是什么。

- 选择风格

- 让文档美观

- 让听众参与

- 做倾听者

- 回复他人



提示 10：

```
It's Both What You Say and the Way You Say It
你说什么和你怎么说同样重要
```

如果你不能有效地向他人传达你的了不起的想法，这些想法就毫无用处。



- 电子邮件交流

按下 [send] 之前进行校对
检查拼写
让格式保持简单
纯文本是通用的，在明确知道对方能够阅读富文本或 HTML 时才使用这些格式
设法让引文减少
一定要注明引用别人电子邮件的出处，在正文中进行引用
不使用语言攻击别人
在发件之前检查收件人名单
将历史电子邮件加以组织和归档



# 第 2 章 注重实效的途径 A Pragmatic Approach

## 7 重复的危害

系统中的每一项知识都必须具有单一、无歧义、权威的表示。

提示 11：

```
DRY - Don't Repeat Yourself
不要重复你自己
```

系统中的每一项知识都必须具有单一、无歧义、权威的表示。



- 重复是怎样发生的

强加的重复（imposed duplication）。 开发者觉得他们无可选择——环境似乎要求重复。

无意的重复（inadvertent duplication）。开发者没有意识到他们在重复信息。

无耐性的重复（impatient duplication）。开发者偷懒，重复，那样似乎更容易。

开发者之间的重复（interdeveloper duplication）。同一团队（或不同团队）的几个人重复了同样的信息。



强加的重复

信息的多种表示

代码中的文档

文档与代码



无意的重复

无耐性的重复

开发者之间的重复



提示 12：

```
Make It Easy to Reuse
让复用变得容易
```

如果复用很容易，人们就会去复用。创造一个支持复用的环境。



## 8 正交性

- 什么是正交性

在计算技术中，该术语用于表示某种不相依赖性或是解耦性。如果两个或更多事物中的一个发生变化，不会影响其他事物，这些事物就是正交的。



- 正交的好处

提示 13：

```
Eliminate Effects Between Unrelated Things
消除无关事物之间的影响
```

设计自足、独立、并具有单一、良好定义的目的的组件。

编写正交的系统，得到两个主要好处：提高生产率与降低风险。



- 提高生产率

改动得以局部化，所以开发时间和测试时间得以降低。



- 降低风险

正交的途径能降低任何开发中固有的风险。



- 项目团队

- 设计

- 工具箱与库

引入第三方工具箱和库时，要注意保持系统的正交性。要明智地选择技术。



- 编码

设计独立、良好定义的组件。

让你的代码保持解耦。

避免使用全局数据。

避免编写相似的函数。



- 测试

- 文档

- 认同正交性



# 可撤销性

> 如果某个想法是你唯一的想法，再没有什么比这更危险的事情了。

要实现某种东西，总有不止一种方式，而且通常有不止一家供应商可以提供第三方产品。如果你参与的项目被短视的、认为只有一种实现方式的观念所牵绊，你也许就会遇到让人不悦的意外之事。许多项目团队会被迫在未来展现之时睁开眼睛



- 可撤消性

提示 14：

```
There Are No Final Decisions
不存在最终决策
```

没有决策是浇铸在石头上的。相反，要把每项决策都视为是写在沙滩上的，并为变化做好计划。



- 灵活的架构



## 10 曳光弹

在黑暗中发光的代码



提示 15：

```
Use Tracer Bullets to Find the Target
用曳光弹找到目标
```

曳光弹能通过试验各种事物并检查它们离目标有多远来让你追踪目标。



- 曳光代码方法

用户能够及早看到能工作的东西。

开发者构建了一个他们能在其中工作的结构。

你有了一个集成平台。

你有了可用于演示的东西。

你将更能够感觉的到工作进展。



- 曳光弹并非总能击中目标

- 曳光代码 vs.原型制作



## 11 原型与便笺

- 应制作原型的事物

架构

已有系统中的新功能

外部数据的结构或内容

第三方工具或组件

性能问题

用户界面设计



提示 16：

```
Prototype to Learn
为了学习而制作原型
```

原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。



构建原型，忽略一些细节

正确性

完整性

健壮性

风格

- 制作架构原型

责任是否得到了良好定义？

协作是否得到了良好定义？

耦合是否得以最小化？

你能否确定潜在的重复？

接口定义和各项约束是否可接受？

模块能否在需要时访问所需数据？



- 怎样“不”使用原型



## 12 领域语言

> 语言的界限就是一个人的世界的界限

计算机语言会影响你思考问题的方式，以及你看待交流的方式。



提示 17：

```
Program Close to the Problem domain
靠近问题领域编程
```



- 具体领域的错误

- 实现小型语言

- 数据语言与命令语言

- 独立语言与嵌入式语言

- 易于开发还是易于维护



## 13 估算

提示 18：

```
Estimate to Avoid Surprises
估算，以避免发生意外
```

在着手之前先进行估算。你将提前发现潜在的问题。



- 多准确才足够准确

建议这样度量时间估算：

| 时长    | 报出估算的单位           |
| ------- | ------------------------ |
| 1~15 天 | 天                       |
| 3~8 周  | 周                       |
| 8~30 周 | 月                       |
| 30+ 周  | 在给出估算前努力思考一下 |




要选择能反映你想要传达的精确度的单位。

- 估算来自哪里

去问已经做过这件事情的人

- 理解提问内容

- 建立系统的模型

- 把模型分解为组件

- 给每个参数指定值

- 计算答案

- 追踪你的估算能力

- 估算项目进度

增量开发：

检查需求

分析风险

设计、实现、集成

向用户确认


提示 19：

```
Iterate the Schedule with the Code
通过代码对进度表进行迭代
```

用你在进行实现时获得的经验提炼项目的时间标度。



- 在被要求进行估算时说什么



# 第 3 章 基本工具 The Basic Tools


## 14 纯文本的威力

提示 20：

```
Keep Knowledge in Plain Text
用纯文本保持知识
```

纯文本不会过时。它能够帮助你有效利用你的工作，并简化调试和测试。

缺点：

1. 与压缩的二进制格式相比，存储纯文本所需空间更多；
2. 要解释及处理纯文本文件，计算上的代价可能更昂贵。



- 文本的威力

保证不过时

杠杆作用

更易于测试



- 保证不过时

人能够阅读的数据形式，以及自描述的数据，将比所有其他的数据形式和创建它们的应用都活得更长久。



- 杠杆作用

- Unix 哲学

- 更易于测试

- 最小公分母



## 15 shell 游戏

GUI 的好处是 WYSIWYG ——所见即所得（what you see is what you get）。缺点是 WYSIAYG ——所见即全部所得（what you see is all you get）。



提示 21：

```
Use the Power of Command Shells
利用命令 shell 的力量
```

当图形用户界面无能为力时使用shell。



- shell 实用程序与 Windows 系统

- 在 Windows 下使用 Unix 工具



## 16 强力编辑

- 一种编辑器



提示 22：

```
Use a Single Editor Well
用好一种编辑器
```

编辑器应该是你的手的延伸；确保你的编辑器是可配置、可扩展和可编程的。



- 编辑器特性

- 可配置

- 可扩展

- 可编程

语法突显。

自动完成。

自动缩进。

初始代码或文档样板。

与帮助系统挂接。

类IDE特性（编译、调试，等等）。



- 生产率

- 然后做什么



## 17 源码控制

> 进步并非由变化组成，二十取决于好记性。不能记住过去的人，被判重复过去。



提示 23：

```
Always Use Source Code Control
总是使用源码控制
```

源码控制是你的工作的时间机器——你能够回到过去。

即使你的团队只有你一个人，你的项目只需一周时间；即使那是“用过就扔”的原型；即使你的工作对象并非源码；



- 源码控制与构建

你可以进行自动的和可重复的产品构建。



# 18 调试

> 这是痛苦的事：
> 看着你自己的烦扰，并且知道
> 不是别人、而是你自己一人所致



- 调试的心理学

调试就是解决问题，要据此发起进攻。

提示 24：

```
Fix the Problem, Not the Blame
要修正问题，而不是发出指责
```

bug 是你的过错还是别人的过错，并不是真的很有关系——它仍然是你的问题，它仍然需要修正。



- 调试的思维方式

> 最容易欺骗的人是一个人自己

提示 25：

```
Don't Panic
不要恐慌
```

做一次深呼吸，思考什么可能是 bug 的原因。

- 测试策略

- 再现 bug（reproduction，亦有“繁殖”之意）

- 使你的数据可视化

DDD（Data Display Debugger）调试器

- 坏变量？检查它们的邻居

- 橡皮鸭

- 消除过程

提示 26：

```
"Select" Isn't Broken
“Select” 没有问题
```

在 OS 或编译器、甚或是第三方产品或库中很少发现 bug。bug 很可能在应用中。



- 造成惊讶的要素

提示 27：

```
Don't Assume it-Prove It
不要假定，要证明
```

在实际环境中——使用真正的数据和边界条件——证明你的假定。

- 调试检查列表

正在报告的问题是底层bug的直接结果，还是只是症状？

bug 真的在编译器里？在 OS 里？或者是在你的代码里？

如果你向同事详细解释这个问题，你会说什么？

如果可疑代码通过了单元测试，测试是否足够完整？如果你用该数据运行单元测试，会发生什么？

造成这个 bug 的条件是否存在于系统中的其他任何地方？



## 19 文本操纵

提示 28：

```
Learn a Text Manipulation Language
学习一种文本操纵语言
```

你用每天的很大一部分时间处理文本，为什么不让计算机替你完成部分工作呢？

数据库 schema 维护

Java 属性（propert）访问

测试数据生成

写书

C 与 Object Pascal 的接口

生成 Web 文档



## 20 代码生成器

提示 29

```
Write Code That Writes Code
编写能编写代码的代码
```

代码生成器能提高你的生产率，并有助于避免重复。

- 被动代码生成器

本质上是参数化模板，根据一组输入生成给定的输出形式。

- 代码生成不一定要很复杂

- 代码生成器不一定要生成代码



# 第 4 章 注重实效的偏执 Pragmatic Paranoia

提示 30：

```
You Can't Write Perfect Software
你不可能写出完美的软件
```

软件不可能完美。保护你的代码和用户，使它（他）们免于能够预见的错误。



## 21 按合约设计

> 没有什么比常识和坦率更让人感到惊讶。

- DBC

前条件（precondition）。为了调用例程，必须为真的条件。例程的需求。在其前条件被违反时，例程决不应被调用。传递好数据是调用者的责任

后条件（postcondition）。例程保证会做的事情，例程完成时世界的状态。例程有后条件这一事实意味着它会结束：不允许有无限循环。

类不变项（class invariant）。类确保从调用者的视角来看，该条件总是为真。



提示 31：

```
Design with Contracts
通过合约进行设计
```

使用合约建立文档，并检验代码所做的事情正好是它声明要做的。

- 断言

- 语言支持

- DBC 与早崩溃

- 不变项的其他用法

- 循环不变项

- 语义不变项

- 出错时要偏向消费者

- 动态合约与代理



## 21 死程序不说谎

提示 32：

```
Crash Early
早崩溃
```

- 要崩溃，不要破坏



## 23 断言式编程

> 在自责中有一种满足感。当我们责备自己时，会觉得再没人有权责备我们。

提示 33：

```
If It Can't Happen, Use Assertions to Ensure That It Won't
如果它不可能发生，用断言确保它不会发生
```

断言验证你的各种假定。在一个不确定的世界里，用断言保护你的代码。



- 让断言开着

- 断言与副作用



## 24 何时使用异常

- 什么是异常情况

提示 34：

```
Use Exceptions for Exceptional Problems
将异常用于异常的问题
```

异常可能会遭受经典的意大利面条式代码的所有可读性和可维护性问题的折磨。将异常保留给异常的事物。



- 错误处理器是另一种选择



# 25 怎样配平资源

提示 35：

```
Finish What You Start
要有始有终
```

只要可能，分配某资源的例程或对象也应该负责解除其分配。



- 嵌套的分配

1. 以与资源分配的次序相反的次序解除资源的分配。
2. 在代码的不同地方分配同一组资源时，总是以相同的次序分配它们。这将降低发生死锁的可能性。



- 对象与异常

- 配平与异常

- 在 C++ 异常机制下配平资源

析构

- 在 Java 中配平资源

finally

- 当你无法配平资源时

1. 顶层结构还负责释放它包含的任何子结构
2. 只是解除顶层结构的分配。它指向的（没有在别处引用的）任何结构都会被遗弃。
3. 如果顶层结构含有任何子结构，它就拒绝解除自身的分配。


- 检查配平



# 第 5 章 弯曲、或折断 Bend, or Break

## 26 解耦与得墨忒耳法则

> 好篱笆促成好邻居



- 使耦合减至最少

某个对象的方法应该只调用属于以下情形的方法：

它自身

传入的任何参数

它创建的对象

组件对象



提示 36：

```
Minimize Coupling Between Modules
使模块之间的耦合减至最少
```

通过编写“羞怯的”代码并应用得墨忒耳法则来避免耦合。

- 物理解耦



## 27 元程序设计

> 再多的天才也无法胜过对细节的专注



- 动态配置

提示 37：

```
Configure, Don't Integrate
要配置，不要集成
```

要将应用的各种技术选择实现为配置选项，而不是通过集成或工程方法实现。



- 元数据驱动的应用

提示 38：

```
Put Abstractions in Code, Details in Metadata
将抽象放进代码，细节放进元数据
```

为一般情况编程，将细节放在被编译的代码库之外。



解除设计的耦合，从而带来更灵活、可适应性更好的程序

通过推迟细节处理，创建更健壮、更抽象的设计——完全推迟到程序之外

无需重新编译应用，就可以对其进行定制

与通用的编程语言的情况相比，可以通过一种大为接近问题领域的方式表示元数据



- 商业逻辑

- 何时进行配置

如果是长期运行的服务器进程，可以在程序运行的过程中重新读取并应用元数据

对于能够快速启动的小型客户 GUI 应用，可以在启动时扫描这样的配置

- 协作式配置

- 不要编写渡渡鸟代码



## 28 时间耦合

提示 39：

```
Analyze Workflow to Imporve Concurrency
分析工作流，以改善并发性
```



提示 40：

```
Design Using Services
用服务进行设计
```

根据服务——独立的、在良好定义、一致的接口之后的并发对象——进行设计。



- 为并发进行设计

- 更整洁的接口

提示 41：

```
Always Design for Concurrency
总是为并发进行设计
```

容许并发，你将会设计出更整洁、具有更少假定的接口。



## 29 它只是视图

- 发布/订阅

提示 42：

```
Separate Views from Models
使视图与模型分离
```

要根据模型和视图设计你的应用，从而以低廉的代码获取灵活性。



- 超越 GUI

视图是对模型（也许是其子集）的一种解释——它无需是图形化的

模型。表示目标对象的抽象数据模型。模型对任何视图或控制器都没有直接的了解。

视图。解释模型的方式。它订阅模型中的变化和来自控制器的逻辑事件。

控制器。控制视图、并向模型提供新数据的途径。它既向模型、也向视图发布事件。让我们看一个非图形例子。



## 30 黑板

提示 43：

```
Sue Blackboards to Coordinate Workflow
用黑板协调工作流
```

用黑板协调完全不同的事实和因素，同时又使各参与方保持独立和隔离。



# 第 6 章 当你编码时 While You Are Coding

## 31 靠巧合编程

提示 44：

```
Don't Program by Coincidence
不要靠巧合编程
```

只依靠可靠的事物。注意偶发的复杂性，不要把幸运的巧合与有目的的计划混为一谈。

怎样深思熟虑地编程：

总是意识到你在做什么。

不要盲目地编程。

按照计划行事

依靠可靠的事物。

为你的假定建立文档

不要只是测试你的代码，还要测试你的假定。

为你的工作划分优先级。

不要做历史的奴隶。



## 32 算法速率

- O() 表示法

O(1)      常量型（访问数组元素，简单语句）
O(lg(n))  对数型（二分查找）
O(n)      线性型（顺序查找）
O(nlg(n)) 比线性差，但不会差很多（快速排序、堆排序）
O(n2)     平方律型（选择和插入排序）
O(n3)     立方型（2n x n 矩阵相乘）
O(Cn)     指数型（旅行商问题，集合划分）



- 常识估算

简单循环。O(n)

嵌套循环。O(m x n)

二分法。O(lg(n))

分而治之。O(nln(n))

组合。



提示 45：

```
Estimate the Order of Your Algorithms
估算你的算法的阶
```

在你编写代码之前，先大致估算事情需要多长时间。



提示 46：

```
Test Your Estimates
测试你的估算
```

对算法的数学分析并不会告诉你每一件事情。在你的代码的目标环境中测定它的速度。



## 33 重构

> 周遭所见，皆是变易与衰败……

- 何时进行重构

你发现了对 DRY 原则的违反。

你发现事物可以更为正交。

你的知识扩展了。

需求演变了。

你需要改善性能。



提示 47：

```
Refactor Early, Refactor Often
早重构，常重构
```

就和你会在花园里除草、并重新布置一样，在需要时对代码进行重写、重做和重新架构。要铲除问题的根源。



- 怎样进行重构

1. 不要试图在重构的同时增加功能

2. 在开始重构之前，确保你拥有良好的测试。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快知道。

- 自动重构



## 34 易于测试的代码

- 单元测试

- 针对合约进行测试



提示 48：

```
Design to Test
为测试而设计
```

在你还没有编写代码时就开始思考测试问题。



- 使用测试装备

- 即兴测试

提示 49：

```
Test Your Software, or Your Users Will
测试你的软件，否则你的用户就得测试
```

无情地测试。不要让你的用户为你查找 bug。



## 35 邪恶的向导

提示 50：

```
Don't Ue Wizard Code You Don't Understand
不要使用你不理解的向导代码
```

向导可以生成大量代码。在你把它们合并进你的项目之前，确保你理解全部这些代码。



# 第 7 章 在项目开始之前 Before The Project

## 36 需求之坑

> 完美，不是在没有什么需要增加、而是在没有什么需要去掉时达到的。

提示 51：

```
Don't not Gather Requirements-Dig for Them
不要手搜集需求－－挖掘他们
```

需求很少存在于表面上。它们深深地埋藏在层层假定、误解和政治手段的下面。



- 挖掘需求

提示 52：

```
Work with a User to Think Like a User
与用户一同工作，以像用户一样思考
```

要了解系统实际上将如何被使用，这是最好的方法。



- 建立需求文档

- 有时接口就是系统

- 用例图

- 规定过度

需求不是架构。需求不是设计，也不是用户界面。需求是需要。

- 看远些



提示 53：

```
Abstractions Live Longer than Details
抽象比细节活的更久
```

“投资”于抽象，而不是实现。抽象能在来自不同的实现和新技术的变化的“攻击”之下存活下去。



- 再抹一层薄薄的薄荷

- 维护维护表

提示 54：

```
Use a Project Glossary
使用项目词汇表
```

创建并维护项目中使用的专用术语和词汇的单一信息源。

把话说出来



## 37 解开不可能的谜题

- 自由度

提示 55：

```
Don't Think Outside the Box-Find the Box
不要在盒子外面思考————要找到盒子
```

在遇到不可能解决的问题时，要确定真正的约束。问问你自己：“它必须以这种方式完成吗？它真的必须完成吗？”



- 一定有更容易的办法

在解决不可能解决的问题时，问问你自己：

有更容易的方法吗？

我是在解决正确的问题吗？

这件事情为什么是一个问题？

是什么使它如此难以解决？

它必须以这种方式完成吗？

它真的必须完成吗？



## 38 等你准备好

> 有时犹豫的人得以保全

提示 56：

```
Listen to Nagging Doubts-Start When You're Ready
倾听反复出现的疑虑————等你准备好再开始
```

你的一生都在积累经验。不要忽视反复出现的疑虑。



## 39 规范陷阱

提示 57：

```
Some Things Are Better Done than Described
对于有些事情“做”胜于“描述”
```

不要掉进规范的螺旋——在某个时刻，你需要开始编码。



## 40 圆圈与箭头

提示 58：

```
Don't Be a Slave to Formal Methods
不要做形式方法的奴隶
```

如果你没有把某项技术放进你的开发实践和能力的语境中，不要盲目地采用它。



- 是否应该使用形式方法

绝对应该。但始终要记住，形式开发方法只是工具箱里的又一种工具。



提示 59：

```
Expensive Tools Do Not Produce Better Designs
昂贵的工具不一定能制作出更好的设计
```

小心供应商的炒作，行业教条、以及价格标签的诱惑。要根据工具的价值判断它们。



# 注重实效的项目 Pragmatic Projects

## 41 注重实效的团队

- 不要留破窗户

- 煮青蛙

- 交流

- 不要重复你自己

- 正交性

提示 60：

```
Organize Around Functionality, Not Job Functions
围绕功能、而不是工作职务进行组织
```

不要把设计师与编码员分开，也不要把测试员与数据建模员分开。按照你构建代码的方式构建团队。



- 自动化

- 知道何时停止绘画



## 42 无处不在的自动化

文明通过增加我们不加思索就能完成的重要操作步骤而取得进步。

- 一切都要自动化

提示 61：

```
Don't Use Manual Procedures
不要使用手工流程
```

shell 脚本或批文件会一次次地以同一顺序执行同样的指令。



- 项目编译

- 生成代码

- 回归测试

- 递归 Make

- 构建自动化

1. 从仓库中签出源码。

2. 从头开始构建项目，在典型情况下是从顶层的 Makefile 开始。

3. 创建可分发映像。

4. 运行规定的测试（make test）。



- 最终构建

- 自动化管理

- 网站生成

- 批准流程



## 43 无情的测试

提示 62：

```
Test Early. Test Ofter. Test Automatically
早测试，常测试，自动测试。
```

与呆在书架上的测试计划相比，每次构建时运行的测试要有效得多。



提示 63：

```
Coding Ain't Dont'Til All the Tests Run
要到通过全部测试，编码才算完成
```

在单独的软件副本上故意引入 bug，以检验测试能够抓住它们。

项目范围测试的三个主要方面：测试什么、怎样测试，以及何时测试。

- 测试什么

单元测试

集成测试

验证和校验（validation and verification）

资源耗尽、错误及恢复

内存空间
磁盘空间
CPU 带宽
时钟时间
磁盘带宽
网络带宽
调色板
视频分辨率

性能测试

可用性测试



- 怎样测试

回归测试

测试数据

演练 GUI 系统

对测试进行测试

彻底测试

- 设计/方法学测试



提示 65：

```
Test State Coverage, Not Code Coverage
测试状态覆盖，而不是代码覆盖
```

确定并测试重要的程序状态。只是测试代码行是不够的。



- 何时进行测试

- 把网收紧

根据产生的 Bug，增加新的测试



提示 66：

```
Find Bugs Once
一个 bug 只抓一次
```

一旦测试员找到一个bug，这应该是测试员最后一次找到它。此后自动测试应该对其进行检查。



## 44 全都是写

> 好记性不如烂笔头。

提示 67：

```
Treat English as Just Another Programming Language
把英语当作又一种编程语言
```

像你编写代码一样编写文档：遵守DRY原则、使用元数据、MVC、自动生成，等等。



内部文档和外部文档

提示 68：

```
Build Documentation In, Don't Bolt lt On
把文档建在里面，不要拴在外面
```

与代码分离的文档不太可能被修正和更新。



- 内部文档

- 代码中的注释

不应出现在源码注释中的一些内容：

文件中的代码导出函数的列表

修订历史

该文件使用的其他文件的列表

文件名



一定要有作者姓名



- 可执行文档

- 文档不是纯文本

编写宏

使文档处于从属地位



- 技术文档撰写者

- 打印还是编排

- 标记语言



## 45 极大的期望

提示 69：

```
Gently Exceed Your User'Expectations
温和的超出用户的期望
```

要理解你的用户的期望，然后给他们的东西要多那么一点。



- 交流期望

- 额外的一英里

让一般用户觉得很好的特性：

气球式帮助或工具提示帮助

快捷键

作为用户手册的补充材料的快速参考指南

彩色化

日志文件分析器

自动化安装

用于检查系统完整性的工具

运行系统的多个版本、以进行培训的能力

为他们的机构定制的 splash 屏幕



## 46 傲慢与偏见

提示 70：

```
Sign Your Work
在你的作品上签名
```

过去时代的手艺人为能在他们的作品上签名而自豪。你也应该如此。